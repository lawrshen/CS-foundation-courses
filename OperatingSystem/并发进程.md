# 概述

无关的并发进程判断：Bernstein条件

R(pi) read,W(pi) write ;两个进程满足：(R(P1)∩W(P2)) ∪ (R(P2) ∩W(P1)) ∪ (W(P1) ∩W(P2)) = { }

# 临界区管理

软件实现：Peterson算法 ：互相谦让 用 inside[2] 和 turn标志

硬件实现：关中断，xchg

存在问题：[^ljq]

[^ljq]:软件方法：复杂度高、效率低，将测试能否进入临界区的责任推给用户，降低系统的可靠性，加重用户编程负担；硬件方法：虽然简单，但硬件设施采用忙式等待测试、浪费CPU时间

# 同步问题

## 生产者消费者问题

信号量 p：请求资源，v：分配资源

## 读者写者问题

56 - 59

## 二元信号量实现一般信号量

60 - 62

## 理发师问题

63 - 64

# 管程

>  同步逻辑的封装机制

# 进程间通信：

信号 管道 消息队列 共享内存 套接字

（线程几乎不存在交换数据问题）



硬中断（内，外 中断） 中断正在执行的程序，转向中断处理程序（外部设备对CPU终端，指令不正常）

信号是  一种 软中断，内核或进程向某个进程发出中断。

# 死锁

P_i	need alloc available (clain = need + alloc)

## 银行家算法：死锁避免

## 资源分配图：死锁检测

**进程**和**资源间**申请及分配关系 の **有向图**

申请边，例 Pi→Rj；分配边，例 Ri→Pj

如果每个资源类型只有一个实例，那么资源分配图中出现环则意味着出现死锁

环：必要不充分，死锁一定有环有环不一定死锁